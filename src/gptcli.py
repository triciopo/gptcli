#!/usr/bin/env python3
"""
gptcli: Run OpenAI's ChatGPT from the command line

This module provides the main logic to
generate responses to prompts using OpenAI's API.
"""

import sys
import argparse
import configparser
import readline  # noqa: F401
import json
import requests

from pathlib import Path
from colorama import Fore
from appdirs import user_config_dir

API_ENDPOINT = "https://api.openai.com/v1/chat/completions"
MODELS_LIST = ["gpt-3.5-turbo", "gpt-4", "gpt-4-32k"]


def post(api_key, prompt, model, num_completions):
    """
    This sends a POST request to the OpenAI API to generate responses.

    Arguments:
        api_key (str): The user's OpenAI API key.
        prompt (str): The prompt to generate a response to.
        model (str): The model to use for generating the response.
        num_completions (int): Number of responses to generate.

    Returns:
        A list of generated responses.
    """
    output = []
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}",
    }
    data = {
        "messages": [{"role": "user", "content": prompt}],
        "model": model, "temperature": 1,
        "n": num_completions,
    }
    try:
        response = requests.post(API_ENDPOINT, headers=headers,
                                 data=json.dumps(data), timeout=60).json()

        choices = response.get("choices", [])
        if not choices:
            error = response.get("error", {})
            print(f"{Fore.LIGHTRED_EX}ERROR: {Fore.RESET + error}")
            if "model" in error:
                print("This most likely means that your API key does not"
                      "have access to this model.")
            sys.exit(1)
        output = [c.get("message", {}).get("content", "") for c in choices if c]
        return "\n\n".join(output)

    except requests.exceptions.RequestException as error:
        print(f"{Fore.LIGHTRED_EX}ERROR: {Fore.RESET}{error}")
        sys.exit(1)


def arg_parser():
    """
    This function creates an argparse parser
    that allows users to input arguments and options.

    Arguments:
        None

    Returns:
        args (Namespace): A Namespace object containing
        the parsed arguments and their values.
    """
    parser = argparse.ArgumentParser(
        description="Run OpenAI's ChatGPT from the commandline"
    )
    parser.add_argument(
        "prompt",
        type=str,
        nargs=argparse.REMAINDER,
        default=argparse.SUPPRESS,
        help="Main prompt (Leave blank to enable chat mode)",
    )
    parser.add_argument(
        "-m",
        "--model",
        type=str,
        nargs=1,
        help="Select model (default: GPT 3.5-turbo)",
    )
    parser.add_argument(
        "-f",
        "--file",
        type=str,
        nargs=1,
        help="Specify a file to include in the prompt",
    )
    parser.add_argument(
        "-n",
        "--num",
        type=int,
        help="Number of responses generated by one input (default: 1)",
    )
    config = get_config()

    # Allow pre-defined prompts to commandline arguments
    existing_args = ["h", "m", "f", "n"]  # Avoid conflicts with existing args
    if config.has_section("args_prompts"):
        for key in config["args_prompts"]:
            cleaned = "".join(filter(str.isalnum, key)).lower()
            if not cleaned or cleaned[0] in existing_args:
                print("Invalid argument set in config.ini")
                print("Format: {argument}: {prompt}")
                sys.exit(1)
            parser.add_argument(
                f"-{cleaned[0]}",
                f"--{cleaned}",
                action="store_true",
                required=False,
                help="Custom prompt generated by the config file.",
            )
            existing_args.append(cleaned[0])
    return parser.parse_args()


def get_config():
    """
    Returns the configuration values for the GPT CLI tool.
    If the configuration file does not exist, creates it with default values.

    Arguments:
        None

    Returns:
        configparser.ConfigParser: An instance of the ConfigParser class containing
        the configuration  values for the GPT CLI tool.
    """
    # Get the path to the configuration file and create a new ConfigParser object
    config_dir = user_config_dir("gptcli")
    config_file = f"{config_dir}/config.ini"
    config_path = Path(config_file)
    config = configparser.ConfigParser()

    # If the configuration file doesn't exist, create it with default values
    if not config_path.is_file():
        config["api"] = {
            "api_key": "<INSERT API KEY HERE>",
            "model": "gpt-3.5-turbo"
        }
        config["file_format_prompt"] = {
            ".txt": "Summarize this for me:",
        }
        config["args_prompts"] = {
            "code": "Answer only with code. Do not include comments or explanation.",
        }
        if not config_path.exists():
            Path(config_dir).mkdir(parents=True, exist_ok=True)
        with open(config_file, "w", encoding="utf-8") as configfile:
            config.write(configfile)

    config.read(config_file)
    return config


def get_prompt_from_file(prompt, file, files_prompt, config, args):
    """
    This function reads a file and generates a prompt to use with GPT.

    Arguments:
    prompt (str): A string containing a prompt.
    file (str): A string containing the path to the file.
    files_prompt (dict): A dictionary containing the prompt based on file extension.
    config (ConfigParser): A ConfigParser object that stores the configuration settings.
    args (argparse.Namespace): Instance of the Namespace class containing the args.

    Returns:
    prompt (str): A string containing the prompt to use with GPT.
    """
    if not Path(file).is_file():
        print(f"Error: file {file} does not exist.")
        sys.exit(1)

    if prompt is None:
        prompt = ""
        file_format = Path(file).suffix
        if has_custom(config, args):
            # Prioritize args instead of file format
            with open(file, "r", encoding="utf-8") as file_content:
                prompt = f"{file_content.read()}"

        elif file_format in files_prompt:
            main_prompt = files_prompt.get(file_format)
            with open(file, "r", encoding="utf-8") as file_content:
                prompt = f"{main_prompt}\n{file_content.read()}"

        else:
            print("Please specify a prompt when using -f.")
            print("Alternatively, create a pre-made prompt "
                  "based on the file extension in the config file.")
            sys.exit(1)
    else:
        with open(file, "r", encoding="utf-8") as file_content:
            prompt = f"\n{file_content.read()}"
    return prompt


def has_custom(config, args):
    """
    Checks whether any custom prompts have been specified on the command line.

    Args:
        config (configparser.ConfigParser): The configuration values for gptcli.
        args (argparse.Namespace): Instance of the Namespace class containing the args.

    Returns:
        bool: True if at least one custom prompt has been specified on the command line.
    """
    for key in config["args_prompts"]:
        if key is not None:
            key_cleaned = "".join(filter(str.isalnum, key)).lower()
            arg_value = getattr(args, key_cleaned)
            if arg_value:
                return True
    return False


def get_custom(config, args):
    """
    Returns the custom prompts specified on the command line.

    Args:
        config (configparser.ConfigParser): The configuration values for gptcli.
        args (argparse.Namespace): Instance of the Namespace class containing the args.

    Returns:
        str: A string containing the custom prompts specified on the command line.
    """
    prompt = []
    if config.has_section("args_prompts"):
        for key in config["args_prompts"]:
            if key is not None:
                key_cleaned = "".join(filter(str.isalnum, key)).lower()
                arg_value = getattr(args, key_cleaned)
                if arg_value:
                    prompt.append(config["args_prompts"][key_cleaned])
    return '\n'.join(prompt)


def chat_mode(api_key, model, num_completions):
    """
    Enters chat mode and prompts the user for input.

    Arguments:
        api_key (str): OpenAI API key.
        model_name (str): Name of the model to use.
        num_completions (int): Number of completions to generate.

    Returns:
        None
    """

    print("Starting chat mode")
    print("Press CTRL+C to stop at anytime")

    # Start chat loop
    while True:
        try:
            prompt = input(f"\n{Fore.LIGHTYELLOW_EX}Prompt:{Fore.RESET} ")
            print(post(api_key, prompt, model, num_completions))
        except KeyboardInterrupt:
            sys.exit(0)


def main():
    # Get arguments and config
    args = arg_parser()
    config = get_config()

    # Get API key from the config
    api_key = config.get('api', 'api_key')
    if not api_key or api_key == "<INSERT API KEY HERE>":
        print(f"{Fore.LIGHTRED_EX}ERROR:{Fore.RESET} API key not found in config file.")
        sys.exit(1)

    # Get model and file extension prompt from the config file.
    model = config["api"]["model"]
    files_prompt = config["file_format_prompt"]

    # Get model, number of completions, file and prompt specified on args
    num_completions = args.num if args.num and args.num >= 1 else 1
    model_name = args.model[0] if args.model else model
    file = args.file[0] if args.file else None
    prompt = " ".join(args.prompt) if args.prompt else None

    if model_name not in MODELS_LIST:
        print(f"{Fore.LIGHTRED_EX}ERROR:{Fore.RESET} Invalid model.")
        print(f"Available models: {', '.join(MODELS_LIST)}")
        sys.exit(1)

    custom_prompt = get_custom(config, args)  # prompt from config file

    if args.prompt:  # Prompt specified
        if custom_prompt:
            prompt = f"{custom_prompt}\n{prompt}"
        if args.file:  # Prompt and file specified
            prompt += get_prompt_from_file(prompt, file, files_prompt, config, args)

    elif not args.prompt and not args.file:  # No file or prompt specified
        chat_mode(api_key, model_name, num_completions)

    elif args.file and not args.prompt:  # File specified but no prompt
        prompt = get_prompt_from_file(None, file, files_prompt, config, args)
        if custom_prompt:
            prompt = f"{custom_prompt}\n{prompt}"

    print(post(api_key, prompt, model_name, num_completions))


if __name__ == "__main__":
    main()
